import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.util.Base64;

public class AESEncryption {
    public static void main(String[] args) throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(256);
        SecretKey key = keyGen.generateKey();

        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        byte[] iv = new byte[16];
        new java.security.SecureRandom().nextBytes(iv);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);

        cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);
        byte[] encrypted = cipher.doFinal("Secret data".getBytes());

        System.out.println("Key: " + Base64.getEncoder().encodeToString(key.getEncoded()));
        System.out.println("IV: " + Base64.getEncoder().encodeToString(iv));
        System.out.println("Ciphertext: " + Base64.getEncoder().encodeToString(encrypted));
    }
}   


from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import base64

# Generate 256-bit key and IV
key = get_random_bytes(32)
iv = get_random_bytes(16)

# Encrypt message
cipher = AES.new(key, AES.MODE_CBC, iv)
message = "Secret data".encode()
pad_len = 16 - (len(message) % 16)
message += bytes([pad_len]) * pad_len
ciphertext = cipher.encrypt(message)

# Output
print("Key:", base64.b64encode(key).decode())
print("IV:", base64.b64encode(iv).decode())
print("Ciphertext:", base64.b64encode(ciphertext).decode())   


const crypto = require('crypto');

const key = crypto.randomBytes(32);
const iv = crypto.randomBytes(16);
const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
let encrypted = cipher.update("Secret data", 'utf8', 'hex');
encrypted += cipher.final('hex');

console.log("Key:", key.toString('hex'));
console.log("IV:", iv.toString('hex'));
console.log("Ciphertext:", encrypted);   


#include <iostream>
#include <openssl/aes.h>

int main() {
    unsigned char key[AES_BLOCK_SIZE];
    unsigned char iv[AES_BLOCK_SIZE];
    RAND_bytes(key, AES_BLOCK_SIZE);
    RAND_bytes(iv, AES_BLOCK_SIZE);

    AES_KEY enc_key;
    AES_set_encrypt_key(key, 256, &enc_key);

    unsigned char plaintext[16] = "Secret data";
    int pad_len = 16 - (strlen((char*)plaintext) % 16);
    for (int i = 0; i < pad_len; i++) plaintext[strlen((char*)plaintext)] = pad_len;

    unsigned char ciphertext[16];
    AES_cbc_encrypt(plaintext, ciphertext, 16, &enc_key, iv, AES_ENCRYPT);

    std::cout << "Ciphertext: ";
    for (int i = 0; i < 16; i++) printf("%02x", ciphertext[i]);
    std::cout << std::endl;
    return 0;
}   


using System;
using System.Security.Cryptography;
using System.Text;

class Program {
    static void Main() {
        using (Aes aes = Aes.Create()) {
            aes.KeySize = 256;
            aes.GenerateKey();
            aes.GenerateIV();

            byte[] data = Encoding.UTF8.GetBytes("Secret data");
            ICryptoTransform encrypt = aes.CreateEncryptor();
            byte[] ciphertext = encrypt.TransformFinalBlock(data, 0, data.Length);

            Console.WriteLine("Key: " + Convert.ToBase64String(aes.Key));
            Console.WriteLine("IV: " + Convert.ToBase64String(aes.IV));
            Console.WriteLine("Ciphertext: " + Convert.ToBase64String(ciphertext));
        }
    }
}   
/
////////////
/////////
////////
////////
